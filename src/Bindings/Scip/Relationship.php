<?php
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: scip.proto

namespace Scip;

use Google\Protobuf\Internal\GPBType;
use Google\Protobuf\Internal\RepeatedField;
use Google\Protobuf\Internal\GPBUtil;

/**
 * Generated from protobuf message <code>scip.Relationship</code>
 */
class Relationship extends \Google\Protobuf\Internal\Message
{
    /**
     * Generated from protobuf field <code>string symbol = 1;</code>
     */
    protected $symbol = '';
    /**
     * When resolving "Find references", this field documents what other symbols
     * should be included together with this symbol. For example, consider the
     * following TypeScript code that defines two symbols `Animal#sound()` and
     * `Dog#sound()`:
     * ```ts
     * interface Animal {
     *           ^^^^^^ definition Animal#
     *   sound(): string
     *   ^^^^^ definition Animal#sound()
     * }
     * class Dog implements Animal {
     *       ^^^ definition Dog#, implementation_symbols = Animal#
     *   public sound(): string { return "woof" }
     *          ^^^^^ definition Dog#sound(), references_symbols = Animal#sound(), implementation_symbols = Animal#sound()
     * }
     * const animal: Animal = new Dog()
     *               ^^^^^^ reference Animal#
     * console.log(animal.sound())
     *                    ^^^^^ reference Animal#sound()
     * ```
     * Doing "Find references" on the symbol `Animal#sound()` should return
     * references to the `Dog#sound()` method as well. Vice-versa, doing "Find
     * references" on the `Dog#sound()` method should include references to the
     * `Animal#sound()` method as well.
     *
     * Generated from protobuf field <code>bool is_reference = 2;</code>
     */
    protected $is_reference = false;
    /**
     * Similar to `references_symbols` but for "Go to implementation".
     * It's common for the `implementation_symbols` and `references_symbols` fields
     * have the same values but that's not always the case.
     * In the TypeScript example above, observe that `implementation_symbols` has
     * the value `"Animal#"` for the "Dog#" symbol while `references_symbols` is
     * empty. When requesting "Find references" on the "Animal#" symbol we don't
     * want to include references to "Dog#" even if "Go to implementation" on the
     * "Animal#" symbol should navigate to the "Dog#" symbol.
     *
     * Generated from protobuf field <code>bool is_implementation = 3;</code>
     */
    protected $is_implementation = false;
    /**
     * Similar to `references_symbols` but for "Go to type definition".
     *
     * Generated from protobuf field <code>bool is_type_definition = 4;</code>
     */
    protected $is_type_definition = false;
    /**
     * Allows overriding the behavior of "Go to definition" and "Find references"
     * for symbols which do not have a definition of their own or could
     * potentially have multiple definitions.
     * For example, in a language with single inheritance and no field overriding,
     * inherited fields can reuse the same symbol as the ancestor which declares
     * the field. In such a situation, is_definition is not needed.
     * On the other hand, in languages with single inheritance and some form
     * of mixins, you can use is_definition to relate the symbol to the
     * matching symbol in ancestor classes, and is_reference to relate the
     * symbol to the matching symbol in mixins.
     * NOTE: At the moment, due to limitations of the SCIP to LSIF conversion,
     * only global symbols in an index are allowed to use is_definition.
     * The relationship may not get recorded if either symbol is local.
     *
     * Generated from protobuf field <code>bool is_definition = 5;</code>
     */
    protected $is_definition = false;

    /**
     * Constructor.
     *
     * @param array $data {
     *     Optional. Data for populating the Message object.
     *
     *     @type string $symbol
     *     @type bool $is_reference
     *           When resolving "Find references", this field documents what other symbols
     *           should be included together with this symbol. For example, consider the
     *           following TypeScript code that defines two symbols `Animal#sound()` and
     *           `Dog#sound()`:
     *           ```ts
     *           interface Animal {
     *                     ^^^^^^ definition Animal#
     *             sound(): string
     *             ^^^^^ definition Animal#sound()
     *           }
     *           class Dog implements Animal {
     *                 ^^^ definition Dog#, implementation_symbols = Animal#
     *             public sound(): string { return "woof" }
     *                    ^^^^^ definition Dog#sound(), references_symbols = Animal#sound(), implementation_symbols = Animal#sound()
     *           }
     *           const animal: Animal = new Dog()
     *                         ^^^^^^ reference Animal#
     *           console.log(animal.sound())
     *                              ^^^^^ reference Animal#sound()
     *           ```
     *           Doing "Find references" on the symbol `Animal#sound()` should return
     *           references to the `Dog#sound()` method as well. Vice-versa, doing "Find
     *           references" on the `Dog#sound()` method should include references to the
     *           `Animal#sound()` method as well.
     *     @type bool $is_implementation
     *           Similar to `references_symbols` but for "Go to implementation".
     *           It's common for the `implementation_symbols` and `references_symbols` fields
     *           have the same values but that's not always the case.
     *           In the TypeScript example above, observe that `implementation_symbols` has
     *           the value `"Animal#"` for the "Dog#" symbol while `references_symbols` is
     *           empty. When requesting "Find references" on the "Animal#" symbol we don't
     *           want to include references to "Dog#" even if "Go to implementation" on the
     *           "Animal#" symbol should navigate to the "Dog#" symbol.
     *     @type bool $is_type_definition
     *           Similar to `references_symbols` but for "Go to type definition".
     *     @type bool $is_definition
     *           Allows overriding the behavior of "Go to definition" and "Find references"
     *           for symbols which do not have a definition of their own or could
     *           potentially have multiple definitions.
     *           For example, in a language with single inheritance and no field overriding,
     *           inherited fields can reuse the same symbol as the ancestor which declares
     *           the field. In such a situation, is_definition is not needed.
     *           On the other hand, in languages with single inheritance and some form
     *           of mixins, you can use is_definition to relate the symbol to the
     *           matching symbol in ancestor classes, and is_reference to relate the
     *           symbol to the matching symbol in mixins.
     *           NOTE: At the moment, due to limitations of the SCIP to LSIF conversion,
     *           only global symbols in an index are allowed to use is_definition.
     *           The relationship may not get recorded if either symbol is local.
     * }
     */
    public function __construct($data = NULL) {
        \GPBMetadata\Scip::initOnce();
        parent::__construct($data);
    }

    /**
     * Generated from protobuf field <code>string symbol = 1;</code>
     * @return string
     */
    public function getSymbol()
    {
        return $this->symbol;
    }

    /**
     * Generated from protobuf field <code>string symbol = 1;</code>
     * @param string $var
     * @return $this
     */
    public function setSymbol($var)
    {
        GPBUtil::checkString($var, True);
        $this->symbol = $var;

        return $this;
    }

    /**
     * When resolving "Find references", this field documents what other symbols
     * should be included together with this symbol. For example, consider the
     * following TypeScript code that defines two symbols `Animal#sound()` and
     * `Dog#sound()`:
     * ```ts
     * interface Animal {
     *           ^^^^^^ definition Animal#
     *   sound(): string
     *   ^^^^^ definition Animal#sound()
     * }
     * class Dog implements Animal {
     *       ^^^ definition Dog#, implementation_symbols = Animal#
     *   public sound(): string { return "woof" }
     *          ^^^^^ definition Dog#sound(), references_symbols = Animal#sound(), implementation_symbols = Animal#sound()
     * }
     * const animal: Animal = new Dog()
     *               ^^^^^^ reference Animal#
     * console.log(animal.sound())
     *                    ^^^^^ reference Animal#sound()
     * ```
     * Doing "Find references" on the symbol `Animal#sound()` should return
     * references to the `Dog#sound()` method as well. Vice-versa, doing "Find
     * references" on the `Dog#sound()` method should include references to the
     * `Animal#sound()` method as well.
     *
     * Generated from protobuf field <code>bool is_reference = 2;</code>
     * @return bool
     */
    public function getIsReference()
    {
        return $this->is_reference;
    }

    /**
     * When resolving "Find references", this field documents what other symbols
     * should be included together with this symbol. For example, consider the
     * following TypeScript code that defines two symbols `Animal#sound()` and
     * `Dog#sound()`:
     * ```ts
     * interface Animal {
     *           ^^^^^^ definition Animal#
     *   sound(): string
     *   ^^^^^ definition Animal#sound()
     * }
     * class Dog implements Animal {
     *       ^^^ definition Dog#, implementation_symbols = Animal#
     *   public sound(): string { return "woof" }
     *          ^^^^^ definition Dog#sound(), references_symbols = Animal#sound(), implementation_symbols = Animal#sound()
     * }
     * const animal: Animal = new Dog()
     *               ^^^^^^ reference Animal#
     * console.log(animal.sound())
     *                    ^^^^^ reference Animal#sound()
     * ```
     * Doing "Find references" on the symbol `Animal#sound()` should return
     * references to the `Dog#sound()` method as well. Vice-versa, doing "Find
     * references" on the `Dog#sound()` method should include references to the
     * `Animal#sound()` method as well.
     *
     * Generated from protobuf field <code>bool is_reference = 2;</code>
     * @param bool $var
     * @return $this
     */
    public function setIsReference($var)
    {
        GPBUtil::checkBool($var);
        $this->is_reference = $var;

        return $this;
    }

    /**
     * Similar to `references_symbols` but for "Go to implementation".
     * It's common for the `implementation_symbols` and `references_symbols` fields
     * have the same values but that's not always the case.
     * In the TypeScript example above, observe that `implementation_symbols` has
     * the value `"Animal#"` for the "Dog#" symbol while `references_symbols` is
     * empty. When requesting "Find references" on the "Animal#" symbol we don't
     * want to include references to "Dog#" even if "Go to implementation" on the
     * "Animal#" symbol should navigate to the "Dog#" symbol.
     *
     * Generated from protobuf field <code>bool is_implementation = 3;</code>
     * @return bool
     */
    public function getIsImplementation()
    {
        return $this->is_implementation;
    }

    /**
     * Similar to `references_symbols` but for "Go to implementation".
     * It's common for the `implementation_symbols` and `references_symbols` fields
     * have the same values but that's not always the case.
     * In the TypeScript example above, observe that `implementation_symbols` has
     * the value `"Animal#"` for the "Dog#" symbol while `references_symbols` is
     * empty. When requesting "Find references" on the "Animal#" symbol we don't
     * want to include references to "Dog#" even if "Go to implementation" on the
     * "Animal#" symbol should navigate to the "Dog#" symbol.
     *
     * Generated from protobuf field <code>bool is_implementation = 3;</code>
     * @param bool $var
     * @return $this
     */
    public function setIsImplementation($var)
    {
        GPBUtil::checkBool($var);
        $this->is_implementation = $var;

        return $this;
    }

    /**
     * Similar to `references_symbols` but for "Go to type definition".
     *
     * Generated from protobuf field <code>bool is_type_definition = 4;</code>
     * @return bool
     */
    public function getIsTypeDefinition()
    {
        return $this->is_type_definition;
    }

    /**
     * Similar to `references_symbols` but for "Go to type definition".
     *
     * Generated from protobuf field <code>bool is_type_definition = 4;</code>
     * @param bool $var
     * @return $this
     */
    public function setIsTypeDefinition($var)
    {
        GPBUtil::checkBool($var);
        $this->is_type_definition = $var;

        return $this;
    }

    /**
     * Allows overriding the behavior of "Go to definition" and "Find references"
     * for symbols which do not have a definition of their own or could
     * potentially have multiple definitions.
     * For example, in a language with single inheritance and no field overriding,
     * inherited fields can reuse the same symbol as the ancestor which declares
     * the field. In such a situation, is_definition is not needed.
     * On the other hand, in languages with single inheritance and some form
     * of mixins, you can use is_definition to relate the symbol to the
     * matching symbol in ancestor classes, and is_reference to relate the
     * symbol to the matching symbol in mixins.
     * NOTE: At the moment, due to limitations of the SCIP to LSIF conversion,
     * only global symbols in an index are allowed to use is_definition.
     * The relationship may not get recorded if either symbol is local.
     *
     * Generated from protobuf field <code>bool is_definition = 5;</code>
     * @return bool
     */
    public function getIsDefinition()
    {
        return $this->is_definition;
    }

    /**
     * Allows overriding the behavior of "Go to definition" and "Find references"
     * for symbols which do not have a definition of their own or could
     * potentially have multiple definitions.
     * For example, in a language with single inheritance and no field overriding,
     * inherited fields can reuse the same symbol as the ancestor which declares
     * the field. In such a situation, is_definition is not needed.
     * On the other hand, in languages with single inheritance and some form
     * of mixins, you can use is_definition to relate the symbol to the
     * matching symbol in ancestor classes, and is_reference to relate the
     * symbol to the matching symbol in mixins.
     * NOTE: At the moment, due to limitations of the SCIP to LSIF conversion,
     * only global symbols in an index are allowed to use is_definition.
     * The relationship may not get recorded if either symbol is local.
     *
     * Generated from protobuf field <code>bool is_definition = 5;</code>
     * @param bool $var
     * @return $this
     */
    public function setIsDefinition($var)
    {
        GPBUtil::checkBool($var);
        $this->is_definition = $var;

        return $this;
    }

}

